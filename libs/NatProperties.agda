module NatProperties where
open import Idris.Prelude.Basics
open import Idris.Prelude.Nat
open import Idris.Prelude.Either
open import Idris.Decidable.Order
open import Preorder
open import TotalPreorder

{-
instance Uninhabited (S n = Z) where
  uninhabited Refl impossible
-}


-- EQ properties

predInjective : (left : Nat) -> (right : Nat) -> Not (S left == S right) -> Not (left == right)
predInjective left right contra = contra ∘ (eqSucc left right)

succInjective' : (left : Nat) -> (right : Nat) -> Not (left == right) -> Not (S left == S right)
succInjective' left right contra = contra ∘ (succInjective left right)



-- LT, LTE properties

lteLemma1 : (m : Nat) -> (n : Nat) -> LTE (S m) n -> LTE m n
lteLemma1 Z     Z      ()
lteLemma1 Z     (S n)  (LTESucc _)  = LTEZero
lteLemma1 (S m) Z      ()
lteLemma1 (S m) (S n)  (LTESucc p)  = LTESucc (lteLemma1 m n p)


ltLemma1 : (m : Nat) -> (n : Nat) -> LT (S m) n -> LT m n
ltLemma1 m n prf = lteLemma1 (S m) n prf


-- ||| LT is contained in LTE
ltInLTE : (m : Nat) -> (n : Nat) -> LT m n -> LTE m n
ltInLTE = lteLemma1


-- ||| EQ is contained in LTE
eqInLTE : (m : Nat) -> (n : Nat) -> m == n -> LTE m n
eqInLTE  Z     n    prf = LTEZero
eqInLTE (S m)  Z    ()
eqInLTE (S m) (S n) prf = LTESucc (eqInLTE m n (succInjective m n prf))





idSuccPreservesLTE : (m : Nat) -> (n : Nat) -> LTE m n -> LTE m (S n)
idSuccPreservesLTE  Z     n    prf = LTEZero
idSuccPreservesLTE (S m)  Z    ()
idSuccPreservesLTE (S m) (S n) prf = LTESucc (idSuccPreservesLTE m n (fromLteSucc prf))


-- ||| Zero is smaller than any successor
ltZS : (m : Nat) -> LT Z (S m)
ltZS  Z    = LTESucc LTEZero
ltZS (S m) = idSuccPreservesLTE (S Z) (S m) (ltZS m)


-- ||| Any number is smaller than its successor
ltIdS : (m : Nat) -> LT m (S m)
ltIdS  Z    = LTESucc LTEZero
ltIdS (S m) = LTESucc (ltIdS m)


-- ||| Any number which is not zero is greater than zero
notZisgtZ : {n : Nat} -> Not (n == Z) -> LT Z n
notZisgtZ {n = Z}   contra = void (contra Refl)
notZisgtZ {n = S m} _      = ltZS m


-- ||| Any number which is greater than zero is not zero
gtZisnotZ : {n : Nat} -> LT Z n -> Not (n == Z)
-- gtZisnotZ () Refl  -- the shorter version works in Adgda but not in Idris
gtZisnotZ {n = Z} ()
gtZisnotZ {S m}   _  ()


-- ||| No number is less than zero
notLTzero : {n : Nat} -> Not (LT n Z)
notLTzero = succNotLTEzero


strengthenLT : (m : Nat) -> (n : Nat) -> LT m (S n) -> Not (m == n) -> LT m n
strengthenLT  Z       n  _       zNEQn   = notZisgtZ (zNEQn ∘ sym)
strengthenLT (S m)  Z    smLTsz  _       = void (notLTzero (fromLteSucc smLTsz))
strengthenLT (S m) (S n) smLTssn smNEQsn = LTESucc mLTn where
  mLTsn : LT m (S n)
  mLTsn = fromLteSucc smLTssn
  mNEQn : Not (m == n)
  mNEQn = predInjective m n smNEQsn
  mLTn  : LT m n
  mLTn  = strengthenLT m n mLTsn mNEQn


monotoneNatPlusLTE : {x : Nat} -> {y : Nat} ->
                     (z : Nat) -> LTE x y -> LTE (z + x) (z + y)
monotoneNatPlusLTE {x} {y}  Z    xLTEy = xLTEy
monotoneNatPlusLTE {x} {y} (S n) xLTEy = LTESucc (monotoneNatPlusLTE {x} {y} n xLTEy)


reflexiveLTE : (n : Nat) -> LTE n n
reflexiveLTE n = lteRefl {n}

transitiveLTE : (m : Nat) -> (n : Nat) -> (o : Nat) ->
                LTE m n -> LTE n o -> LTE m o
transitiveLTE  Z       n     o   LTEZero                 nlteo  = LTEZero
transitiveLTE (S m) (S n) (S o) (LTESucc mlten) (LTESucc nlteo) = LTESucc (transitiveLTE m n o mlten nlteo)

totalLTE : (m : Nat) -> (n : Nat) -> Either (LTE m n) (LTE n m)
totalLTE  Z    n     = Left LTEZero
totalLTE (S m) Z     = Right LTEZero
totalLTE (S m) (S n) with (totalLTE m n)
... | (Left  p) = Left  (LTESucc p)
... | (Right p) = Right (LTESucc p)

preorderNatLTE : Preorder Nat
preorderNatLTE =
  MkPreorder LTE reflexiveLTE transitiveLTE

totalPreorderNatLTE : TotalPreorder Nat
totalPreorderNatLTE =
  MkTotalPreorder LTE reflexiveLTE transitiveLTE totalLTE

-- Decidability


-- ||| LTE is decidable
decLTE : (m : Nat) -> (n : Nat) -> Dec (LTE m n)
decLTE = Idris.Decidable.Order.lte

-- ||| LT is decidable
decLT : (m : Nat) -> (n : Nat) -> Dec (LT m n)
decLT m n = decLTE (S m) n

{- TODO





Uniqueness

> ||| LTE is unique
> uniqueLTE : (p1 : LTE m n) -> (p2 : LTE m n) -> p1 == p2
> uniqueLTE  LTEZero     LTEZero    = Refl
> uniqueLTE  LTEZero    (LTESucc p) impossible
> uniqueLTE (LTESucc p)  LTEZero    impossible
> uniqueLTE (LTESucc p) (LTESucc q) = cong (uniqueLTE p q)

> ||| LT is unique
> uniqueLT : (p1 : LT m n) -> (p2 : LT m n) -> p1 == p2
> uniqueLT {m} {n} = uniqueLTE {m = S m} {n = n}

-}
